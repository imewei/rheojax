"""Hébraud–Lequeux (HL) Model implementation.

This module implements the Hébraud–Lequeux mean-field elastoplastic model
for yield-stress fluids and soft glassy materials. It integrates JAX-accelerated
kernels for high-performance simulation of flow curves, creep, relaxation,
and LAOS protocols.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

import numpy as np

from rheojax.core.base import BaseModel
from rheojax.core.inventory import Protocol
from rheojax.core.jax_config import safe_import_jax
from rheojax.core.parameters import ParameterSet
from rheojax.core.registry import ModelRegistry
from rheojax.logging import get_logger, log_fit
from rheojax.utils.hl_kernels import (
    creep_kernel,
    laos_kernel,
    relaxation_kernel,
    run_creep,
    run_flow_curve,
    run_laos,
    run_relaxation,
    run_startup,
    startup_kernel,
)

# Safe JAX import (enforces float64)
jax, jnp = safe_import_jax()

if TYPE_CHECKING:
    import jax.numpy as jnp_typing
else:
    jnp_typing = Any

# Module logger
logger = get_logger(__name__)


@ModelRegistry.register(
    "hebraud_lequeux",
    protocols=[
        Protocol.FLOW_CURVE,
        Protocol.CREEP,
        Protocol.RELAXATION,
        Protocol.STARTUP,
        Protocol.OSCILLATION,
        Protocol.LAOS,
    ],
)
class HebraudLequeux(BaseModel):
    """Hébraud–Lequeux (HL) Model for Soft Glassy Materials.

    The HL model (1998) is a mean-field description of yield-stress fluids where
    mesoscopic blocks of stress evolve via elastic loading, plastic yielding, and
    stress diffusion (mechanical noise) generated by yielding events elsewhere.

    It predicts:
    - Finite yield stress for coupling parameter alpha < 0.5
    - Herschel-Bulkley flow curves (stress ~ gdot^0.5) near yield
    - Creep and delayed yielding
    - Stress overshoots in startup flow
    - Non-linear LAOS response

    Parameters:
        alpha: Coupling parameter (dimensionless). Controls phase state.
               alpha < 0.5: Glassy (yield stress)
               alpha >= 0.5: Fluid (no yield stress)
        tau: Microscopic yield timescale (s).
        sigma_c: Critical yield stress threshold (Pa).

    Attributes:
        parameters: ParameterSet containing alpha, tau, sigma_c.
    """

    def __init__(self):
        """Initialize Hébraud–Lequeux Model."""
        super().__init__()

        # Create parameter set
        self.parameters = ParameterSet()

        # alpha: Coupling parameter
        # Range: 0 to 1. alpha=0.5 is the critical point.
        self.parameters.add(
            name="alpha",
            value=0.3,
            bounds=(0.0, 1.0),
            units="dimensionless",
            description="Coupling parameter (alpha < 0.5 -> yield stress)",
        )

        # tau: Yield timescale
        self.parameters.add(
            name="tau",
            value=1.0,
            bounds=(1e-6, 1e4),
            units="s",
            description="Microscopic yield timescale",
        )

        # sigma_c: Yield stress threshold
        self.parameters.add(
            name="sigma_c",
            value=1.0,
            bounds=(1e-3, 1e6),
            units="Pa",
            description="Critical yield stress threshold",
        )

        # Internal state for protocol settings
        self._test_mode: str | None = None
        self._last_fit_kwargs: dict[str, Any] = {}
        # Store metadata for reconstructing time axes in Bayesian mode
        self._fit_data_metadata: dict[str, Any] = {}

        # Grid settings (can be adjusted by user)
        self.grid_n_bins = 501
        self.grid_sigma_factor = 5.0  # grid extends to sigma_c * factor

    def _get_grid_params(self, sigma_c_val: float | None = None) -> tuple[float, int]:
        """Get grid parameters based on current or provided sigma_c."""
        if sigma_c_val is None:
            sigma_c_val = self.parameters.get_value("sigma_c")

        # Ensure grid covers relevant stress range
        # Minimum sigma_max of 5.0 to handle standard normalized cases
        # Otherwise scale with sigma_c
        sigma_max = max(5.0, sigma_c_val * self.grid_sigma_factor)
        return sigma_max, self.grid_n_bins

    def _fit(
        self,
        X: np.ndarray,
        y: np.ndarray,
        **kwargs: Any,
    ) -> HebraudLequeux:
        """Fit HL model parameters to data.

        Args:
            X: Independent variable (shear rate, time, etc.)
            y: Dependent variable (stress, viscosity, compliance, etc.)
            **kwargs: Must include 'test_mode'. Options:
                test_mode: Protocol ('steady_shear', 'creep', 'relaxation',
                    'startup', 'laos')
                Other optimizer/protocol-specific parameters (e.g. gamma0)
        """
        test_mode: str | None = kwargs.pop("test_mode", None)
        if test_mode is None:
            raise ValueError("test_mode must be specified for HL fitting")

        self._test_mode = test_mode
        self._last_fit_kwargs = kwargs

        # Store metadata for Bayesian reconstruction
        if len(X) > 0:
            self._fit_data_metadata = {
                "t_max": float(X[-1]) if test_mode != "steady_shear" else None,
                "len_X": len(X),
                "X_start": float(X[0]),
                "X_end": float(X[-1]),
            }

        with log_fit(logger, model="HebraudLequeux", data_shape=X.shape) as ctx:
            logger.info(f"Fitting HL model in mode: {test_mode}")
            ctx["test_mode"] = test_mode

            if test_mode == "steady_shear":
                self._fit_steady_shear(X, y, **kwargs)
            elif test_mode == "creep":
                self._fit_creep(X, y, **kwargs)
            elif test_mode == "relaxation":
                self._fit_relaxation(X, y, **kwargs)
            elif test_mode == "startup":
                self._fit_startup(X, y, **kwargs)
            elif test_mode == "laos":
                self._fit_laos(X, y, **kwargs)
            else:
                raise ValueError(f"Unsupported test mode: {test_mode}")

            self.fitted_ = True
        return self

    def _fit_steady_shear(self, gdot: np.ndarray, stress: np.ndarray, **kwargs):
        """Fit flow curve."""
        from rheojax.utils.optimization import (
            create_least_squares_objective,
            nlsq_optimize,
        )

        gdot_jax = jnp.asarray(gdot, dtype=jnp.float64)
        stress_jax = jnp.asarray(stress, dtype=jnp.float64)

        # Grid sizing
        sigma_max, n_bins = self._get_grid_params()

        # Calculate simulation duration for steady state.
        # Need enough strain to yield: yield strain ~ sigma_c (G=1 normalized).
        # Safe margin: strain = 20 * max(1, sigma_c). Also need time >> tau.

        sigma_c_val = self.parameters.get_value("sigma_c") or 1.0
        tau_val = self.parameters.get_value("tau") or 1.0

        # Estimate min gdot (taking non-zero min)
        gdot_abs = np.abs(gdot)
        gdot_min = np.min(gdot_abs[gdot_abs > 1e-9]) if np.any(gdot_abs > 1e-9) else 1.0

        strain_target = 10.0 * max(1.0, sigma_c_val)
        time_strain = strain_target / gdot_min
        time_relax = 10.0 * tau_val

        t_total = max(time_strain, time_relax)
        dt = 0.005
        steps = int(t_total / dt) + 1

        # Cap steps to avoid freezing
        steps = min(steps, 1_000_000)
        steps = max(steps, 5000)

        def model_fn(x_data, params):
            alpha, tau, sigma_c = params
            return run_flow_curve(
                x_data, alpha, tau, sigma_c, dt, sigma_max, n_bins, steps=steps
            )

        objective = create_least_squares_objective(
            model_fn, gdot_jax, stress_jax, normalize=True
        )

        result = nlsq_optimize(
            objective,
            self.parameters,
            use_jax=kwargs.get("use_jax", True),
            max_iter=kwargs.get("max_iter", 1000),
        )

        if not result.success:
            logger.warning(f"Optimization warning: {result.message}")

    def _fit_creep(self, t: np.ndarray, compliance: np.ndarray, **kwargs):
        """Fit creep compliance."""
        from rheojax.utils.optimization import (
            create_least_squares_objective,
            nlsq_optimize,
        )

        stress_target = kwargs.get("stress_target")
        if stress_target is None:
            raise ValueError(
                "stress_target must be provided in kwargs for creep fitting"
            )

        t_jax = jnp.asarray(t, dtype=jnp.float64)
        J_jax = jnp.asarray(compliance, dtype=jnp.float64)

        # Calculate n_steps statically for the objective function
        dt = 0.005  # Default from kernels
        t_max = float(t[-1])
        n_steps = int(t_max / dt) + 1

        # Grid sizing
        sigma_max, n_bins = self._get_grid_params()

        def model_fn(x_data, params):
            alpha, tau, sigma_c = params
            time_hist, gamma_hist = creep_kernel(
                n_steps, stress_target, alpha, tau, sigma_c, 1.0, dt, sigma_max, n_bins
            )

            # Add t=0
            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            gamma_full = jnp.concatenate([jnp.array([0.0]), gamma_hist])

            gamma_interp = jnp.interp(x_data, time_full, gamma_full)
            return gamma_interp / stress_target

        objective = create_least_squares_objective(
            model_fn, t_jax, J_jax, normalize=True, use_log_residuals=True
        )

        result = nlsq_optimize(
            objective,
            self.parameters,
            use_jax=True,
            max_iter=kwargs.get("max_iter", 500),
        )

        if not result.success:
            logger.warning(f"Optimization warning: {result.message}")

    def _fit_relaxation(self, t: np.ndarray, modulus: np.ndarray, **kwargs):
        """Fit stress relaxation modulus."""
        from rheojax.utils.optimization import (
            create_least_squares_objective,
            nlsq_optimize,
        )

        gamma0 = kwargs.get("gamma0")
        if gamma0 is None:
            raise ValueError(
                "gamma0 (step strain) must be provided in kwargs for relaxation fitting"
            )

        t_jax = jnp.asarray(t, dtype=jnp.float64)
        G_jax = jnp.asarray(modulus, dtype=jnp.float64)

        dt = 0.005
        t_max = float(t[-1])
        n_steps = int(t_max / dt) + 1

        # Grid sizing
        sigma_max, n_bins = self._get_grid_params()

        def model_fn(x_data, params):
            alpha, tau, sigma_c = params
            time_hist, stress_hist = relaxation_kernel(
                n_steps, gamma0, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )

            # Initial stress approximation
            init_stress = gamma0

            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([init_stress]), stress_hist])

            sigma_interp = jnp.interp(x_data, time_full, stress_full)
            return sigma_interp / gamma0

        objective = create_least_squares_objective(
            model_fn, t_jax, G_jax, normalize=True, use_log_residuals=True
        )

        result = nlsq_optimize(
            objective,
            self.parameters,
            use_jax=True,
            max_iter=kwargs.get("max_iter", 500),
        )

        if not result.success:
            logger.warning(f"Optimization warning: {result.message}")

    def _fit_startup(self, t: np.ndarray, stress: np.ndarray, **kwargs):
        """Fit startup stress transient."""
        from rheojax.utils.optimization import (
            create_least_squares_objective,
            nlsq_optimize,
        )

        gdot = kwargs.get("gdot")
        if gdot is None:
            raise ValueError(
                "gdot (shear rate) must be provided in kwargs for startup fitting"
            )

        t_jax = jnp.asarray(t, dtype=jnp.float64)
        stress_jax = jnp.asarray(stress, dtype=jnp.float64)

        dt = 0.005
        t_max = float(t[-1])
        n_steps = int(t_max / dt) + 1

        # Grid sizing
        sigma_max, n_bins = self._get_grid_params()

        def model_fn(x_data, params):
            alpha, tau, sigma_c = params
            time_hist, stress_hist = startup_kernel(
                n_steps, gdot, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )

            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([0.0]), stress_hist])

            return jnp.interp(x_data, time_full, stress_full)

        objective = create_least_squares_objective(
            model_fn, t_jax, stress_jax, normalize=True
        )

        result = nlsq_optimize(
            objective,
            self.parameters,
            use_jax=True,
            max_iter=kwargs.get("max_iter", 500),
        )

        if not result.success:
            logger.warning(f"Optimization warning: {result.message}")

    def _fit_laos(self, t: np.ndarray, stress: np.ndarray, **kwargs):
        """Fit LAOS stress response."""
        from rheojax.utils.optimization import (
            create_least_squares_objective,
            nlsq_optimize,
        )

        gamma0 = kwargs.get("gamma0")
        omega = kwargs.get("omega")
        if gamma0 is None or omega is None:
            raise ValueError("gamma0 and omega must be provided for LAOS fitting")

        t_jax = jnp.asarray(t, dtype=jnp.float64)
        stress_jax = jnp.asarray(stress, dtype=jnp.float64)

        dt = 0.005
        t_max = float(t[-1])
        n_steps = int(t_max / dt) + 1

        # Grid sizing
        sigma_max, n_bins = self._get_grid_params()

        def model_fn(x_data, params):
            alpha, tau, sigma_c = params
            time_hist, stress_hist = laos_kernel(
                n_steps, gamma0, omega, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )

            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([0.0]), stress_hist])

            return jnp.interp(x_data, time_full, stress_full)

        objective = create_least_squares_objective(
            model_fn, t_jax, stress_jax, normalize=True
        )

        result = nlsq_optimize(
            objective,
            self.parameters,
            use_jax=True,
            max_iter=kwargs.get("max_iter", 500),
        )

        if not result.success:
            logger.warning(f"Optimization warning: {result.message}")

    def _predict(self, X: np.ndarray, **kwargs: Any) -> np.ndarray:
        """Predict response using fitted parameters and stored test_mode."""
        if self._test_mode is None:
            raise ValueError("Model not fitted or test_mode not set.")

        X_jax = jnp.asarray(X, dtype=jnp.float64)
        alpha = self.parameters.get_value("alpha")
        tau = self.parameters.get_value("tau")
        sigma_c = self.parameters.get_value("sigma_c")

        sigma_max, n_bins = self._get_grid_params(sigma_c)

        # The run_xxx functions in hl_kernels.py are now wrappers that
        # handle t_max/n_steps correctly (computes it from X array)
        # So we can use them directly here as X is provided at runtime.

        if self._test_mode == "steady_shear":
            # For flow curve, we need to pass steps calculated from gdot range
            # Replicate logic from _fit_steady_shear but for prediction
            gdot = X_jax
            gdot_abs = jnp.abs(gdot)
            # Use JAX-safe estimate (predict usually takes concrete X)
            gdot_min = jnp.min(jnp.where(gdot_abs > 1e-9, gdot_abs, 1e9))
            # Fallback if all zero
            gdot_min = jnp.where(gdot_min > 1e8, 1.0, gdot_min)

            strain_target = 10.0 * max(1.0, float(sigma_c or 1.0))
            time_strain = strain_target / gdot_min
            time_relax = 10.0 * float(tau or 1.0)

            t_total = jnp.maximum(time_strain, time_relax)
            dt = 0.005
            steps = int(t_total / dt) + 1
            steps = min(steps, 1_000_000)
            steps = max(steps, 5000)

            return np.array(
                run_flow_curve(
                    X_jax,
                    float(alpha or 0.5),
                    float(tau or 1.0),
                    float(sigma_c or 1.0),
                    dt,
                    float(sigma_max),
                    int(n_bins),
                    steps=int(steps),
                )
            )

        elif self._test_mode == "creep":
            stress_target = self._last_fit_kwargs.get("stress_target", 1.0)
            return np.array(
                run_creep(
                    X_jax,
                    float(stress_target),
                    float(alpha or 0.5),
                    float(tau or 1.0),
                    float(sigma_c or 1.0),
                    1.0,
                    0.005,
                    float(sigma_max),
                    int(n_bins),
                )
            )
        elif self._test_mode == "relaxation":
            gamma0 = self._last_fit_kwargs.get("gamma0", 1.0)
            return np.array(
                run_relaxation(
                    X_jax,
                    float(gamma0),
                    float(alpha or 0.5),
                    float(tau or 1.0),
                    float(sigma_c or 1.0),
                    0.005,
                    float(sigma_max),
                    int(n_bins),
                )
            )
        elif self._test_mode == "startup":
            gdot = self._last_fit_kwargs.get("gdot", 1.0)
            return np.array(
                run_startup(
                    X_jax,
                    float(gdot),
                    float(alpha or 0.5),
                    float(tau or 1.0),
                    float(sigma_c or 1.0),
                    0.005,
                    float(sigma_max),
                    int(n_bins),
                )
            )
        elif self._test_mode == "laos":
            gamma0 = self._last_fit_kwargs.get("gamma0", 1.0)
            omega = self._last_fit_kwargs.get("omega", 1.0)
            return np.array(
                run_laos(
                    X_jax,
                    float(gamma0),
                    float(omega),
                    float(alpha or 0.5),
                    float(tau or 1.0),
                    float(sigma_c or 1.0),
                    0.005,
                    float(sigma_max),
                    int(n_bins),
                )
            )
        else:
            raise ValueError(f"Unknown test mode: {self._test_mode}")

    def model_function(
        self, X: np.ndarray, params: np.ndarray, test_mode: str | None = None
    ):
        """Model function for Bayesian inference (NumPyro NUTS).

        Args:
            X: Input array
            params: Parameter values [alpha, tau, sigma_c]
            test_mode: Override test mode
        """
        mode = test_mode or self._test_mode
        if mode is None:
            raise ValueError("test_mode required for Bayesian inference")

        alpha, tau, sigma_c = params
        X_jax = jnp.asarray(X, dtype=jnp.float64)

        # Use fixed grid for Bayesian (sigma_c is dynamic tracer, can't resize
        # in JIT). Choose a large grid covering sigma_c prior range (1e-3 to 1e6).
        # JIT requires static shapes, so we use a fixed conservative grid.
        sigma_max = 50.0  # Conservative default for normalized data
        n_bins = 501

        dt = 0.005

        # Helper to get n_steps safely
        def get_n_steps(x_arr):
            # If x_arr is concrete, we can calculate n_steps
            # If it's a tracer, we need the stored metadata
            try:
                t_max = float(x_arr[-1])
                return int(t_max / dt) + 1
            except Exception as e:
                # Fallback to stored metadata if available
                if self._fit_data_metadata and "t_max" in self._fit_data_metadata:
                    t_max = self._fit_data_metadata["t_max"]
                    return int(t_max / dt) + 1
                else:
                    raise RuntimeError(
                        "Cannot determine n_steps for Bayesian inference."
                    ) from e

        # Dispatch to kernels
        if mode == "steady_shear":
            return run_flow_curve(X_jax, alpha, tau, sigma_c, dt, sigma_max, n_bins)

        elif mode == "creep":
            n_steps = get_n_steps(X_jax)
            stress_target = self._last_fit_kwargs.get("stress_target", 1.0)

            time_hist, gamma_hist = creep_kernel(
                n_steps, stress_target, alpha, tau, sigma_c, 1.0, dt, sigma_max, n_bins
            )
            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            gamma_full = jnp.concatenate([jnp.array([0.0]), gamma_hist])
            return jnp.interp(X_jax, time_full, gamma_full) / stress_target

        elif mode == "relaxation":
            n_steps = get_n_steps(X_jax)
            gamma0 = self._last_fit_kwargs.get("gamma0", 1.0)

            time_hist, stress_hist = relaxation_kernel(
                n_steps, gamma0, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )
            # Init stress approx
            init_stress = gamma0
            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([init_stress]), stress_hist])
            return jnp.interp(X_jax, time_full, stress_full) / gamma0

        elif mode == "startup":
            n_steps = get_n_steps(X_jax)
            gdot = self._last_fit_kwargs.get("gdot", 1.0)

            time_hist, stress_hist = startup_kernel(
                n_steps, gdot, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )
            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([0.0]), stress_hist])
            return jnp.interp(X_jax, time_full, stress_full)

        elif mode == "laos":
            n_steps = get_n_steps(X_jax)
            gamma0 = self._last_fit_kwargs.get("gamma0", 1.0)
            omega = self._last_fit_kwargs.get("omega", 1.0)

            time_hist, stress_hist = laos_kernel(
                n_steps, gamma0, omega, alpha, tau, sigma_c, dt, sigma_max, n_bins
            )
            time_full = jnp.concatenate([jnp.array([0.0]), time_hist])
            stress_full = jnp.concatenate([jnp.array([0.0]), stress_hist])
            return jnp.interp(X_jax, time_full, stress_full)

        else:
            raise ValueError(f"Unknown test mode for Bayesian: {mode}")

    def get_phase_state(self) -> str:
        """Return the phase state based on alpha."""
        alpha = self.parameters.get_value("alpha") or 0.3
        if alpha < 0.5:
            return "glass"
        else:
            return "fluid"
